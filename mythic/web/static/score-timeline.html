<!DOCTYPE html>
<html>

<head>
<title>Mythic+</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="UTF-8">
<link rel="stylesheet" href="css/angular-material.min.css">
</head>

<body ng-app="MyApp" ng-controller="MyController" ng-cloak>
	<section layout="column" style="margin: 5px;">
		<section layout="row">
			<input flex type="text" ng-model="characterName" /> <select
				name="server" ng-model="server">
				<option ng-repeat="server in servers" value="{{server}}">{{server}}</option>
			</select>
			<md-button ng-disabled="ready != 1" ng-click="search(true)" class="md-primary md-raised">조회</md-button>
		</section>

		<section flex layout="row">
			<div flex id="timeline" style="height: 100vh"></div>
		</section>
	</section>

	<script src="js/angular.min.js"></script>
	<script src="js/angular-animate.min.js"></script>
	<script src="js/angular-aria.min.js"></script>
	<script src="js/angular-messages.min.js"></script>
	<script src="js/angular-material.min.js"></script>

    <script src="//unpkg.com/vis-charts@latest/dist/vis.min.js"></script>
    <link href="//unpkg.com/vis-charts@latest/dist/vis.min.css" rel="stylesheet" type="text/css">

	<script>

        var app = angular.module('MyApp', ['ngMaterial']);
        app.controller('MyController', MyController);
        var graph2d

        function MyController($scope, $http, $timeout) {
            $scope.characterName = ''
            $scope.server = ''
            $scope.servers = {}
            $scope.serverNames = []

            $http({
                method: 'GET',
                url: 'form/realms',
            }).then(function (resp) {
                $scope.servers = resp.data
                for (var key in $scope.servers) {
                    $scope.serverNames.push($scope.servers[key])
                }
                $scope.server = $scope.serverNames[0]

                if (window.localStorage) {
                    const server = window.localStorage.getItem('relation_server')
                    const run = parseInt(window.localStorage.getItem('relation_run'))
                    if ($scope.serverNames.indexOf(server) >= 0) {
                        $scope.server = server
                    }
                    $scope.characterName = window.localStorage.getItem('relation_character')
                    if (run > 0) {
                        $scope.minimumRun = run
                    }
                }
                $scope.ready |= 1
            }).catch(function () {
            })



            $scope.search = function () {
                if ($scope.characterName == '') {
                    return
                }
                $scope.characterName = $scope.characterName.substring(0, 1).toUpperCase() +
                    $scope.characterName.substring(1).toLowerCase()
                if (window.localStorage) {
                    window.localStorage.setItem('relation_server', $scope.server)
                    window.localStorage.setItem('relation_character', $scope.characterName)
                }



                $http({
                    method: 'GET',
                    url: 'char/mythic_rating/' + encodeURI($scope.server) + '/' + encodeURI($scope.characterName),
                }).then(function (resp) {
                    console.log(resp.data)

                    let period = 0
                    let dungeonScore = {}
                    let minPeriod = 0
                    let maxPeriod = 0

                    let items = []
                    let groups = [{
                        id: '0',
                        content: "total",
                        options: {
                            excludeFromStacking: true
                        }
                    }]

                    const addSummary = () => {
                        let score = 0
                        for (let did in dungeonScore) {
                            const arr = dungeonScore[did]
                            const dscore = Math.max(arr[0], arr[1]) * 1.5 + Math.min(arr[0], arr[1]) * 0.5
                            score += dscore

                            items.push({
                                x: period,
                                y: dscore,
                                group: String(did),
                                label: {
                                    content: String(parseInt(dscore)),
                                    xOffset: -15,
                                    yOffset: 20
                                }
                            })
                        }
                        if (score > 0) {
                            items.push({
                                x: period,
                                y: score,
                                group: '0',
                                label: {
                                    content: String(parseInt(score)),
                                    xOffset: -20,
                                    yOffset: -20
                                }
                            })
                        }
                    }

                    
                    resp.data.forEach(data => {
                        if (data.period != period) {
                            if (period == 0) {
                                minPeriod = data.period
                            } else {
                                addSummary()
                            }
                            period = data.period
                            maxPeriod = period
                        }
                        if (!dungeonScore[data.dungeon_id]) {
                            dungeonScore[data.dungeon_id] = [0, 0]
                        }
                        dungeonScore[data.dungeon_id][period % 2] = Math.max(dungeonScore[data.dungeon_id][period % 2], data.mythic_rating)
                        if (!(groups.some(g => g.id == String(data.dungeon_id)))) {
                            groups.push({
                                id: String(data.dungeon_id),
                                content: data.dungeon_name
                            })
                        }
                    })
                    addSummary()
                    if (items.length >= 0) {
                        var container = document.getElementById('timeline')
                        container.innerHTML = ''
                        graph2d = new vis.Graph2d(container, items, groups, {
                            style: 'bar',
                            stack: true,
                            legend: true,
                            min: minPeriod - 1,
                            max: maxPeriod + 1,
                            start: minPeriod - 1,
                            end: maxPeriod + 1,
                            zoomable: false,
                            // barChart: { width: 50, align: 'center' },
                            drawPoints: {
                                onRender: function(item, group, grap2d) {
                                    return item.label != null;
                                },
                                style: 'circle'
                            },                        
                            dataAxis: {
                                icons: true,
                                left: {
                                    range: {
                                        min: 0,
                                        max: Math.ceil(Math.max.apply(null, items.filter(it => it.group == '0').map(it => it.y)) / 100) * 100 + 200
                                    }
                                }
                            },
                            height: 900
                        })
                    }
                }).catch(function () {
                })
            }
        }
    </script>
</body>

</html>
